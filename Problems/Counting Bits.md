#### Counting Bits
#### Writer: Haram Ryu
#### Refer: LeetCode

## 문제 설명
음수가 아닌 정수 num이 입력됐을 때 0 ≤ i ≤ num인 모든 i에 대해서 이진수로 표현했을때 1의 갯수를 슬라이스로 출력
***예시***
```
Input: 2
Output: [0,1,1]

Input: 5
Output: [0,1,1,2,1,2]
```
## 전제
- 시간복잡도 O(n*sizeof(integer))로 하기는 쉬운데, O(n)으로 할 수 있겠나
- 공간복잡도도 O(n)가 되어야 함
- 빌트인 함수를 사용하지 않고 할 수 있겠나
## 솔루션
```
    func countBits(num int) []int {
        var result []int
        for i := 0; i <= num; i++ {
            tmp := i
            tmp = (tmp & 0x55555555) + ((tmp >> 1) & 0x55555555)
            tmp = (tmp & 0x33333333) + ((tmp >> 2) & 0x33333333)
            tmp = (tmp & 0x0f0f0f0f) + ((tmp >> 4) & 0x0f0f0f0f)
            tmp = (tmp & 0x00ff00ff) + ((tmp >> 8) & 0x00ff00ff)
            tmp = (tmp & 0x0000ffff) + ((tmp >> 16) & 0x0000ffff)
            result = append(result, tmp)
        }
        return result
    }
```
- 과정중에 AND 연산을 하게되는 숫자들은 이진수로 바꿔보면 다음과 같음
    - 0x55555555 → 01010101010101010101010101010101
    - 0x33333333 → 00110011001100110011001100110011
    - 0x0f0f0f0f → 00001111000011110000111100001111
    - 0X00ff00ff → 00000000111111110000000011111111
    - 0x0000ffff → 00000000000000001111111111111111
- 맨처음에는 홀수 자리를 골라내고, 하나를 오른쪽으로 옮기면 짝수 자리를 골라낼 수 있음
- 계속 체처럼 걸러서 1들을 계속 오른쪽으로 옮겨감
- 위의 방법으로 최대 32bit의 정수까지 처리 가능
